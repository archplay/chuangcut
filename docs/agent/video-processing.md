# 视频处理链路

本文档按链路阶段组织，每个链路内按视频来源分类：
- **Vertex AI 模式**: 系统上传到 GCS
- **AI Studio 模式**: 系统上传到本地 + File API
- **外部存储桶**: R2/S3/其他 HTTPS URL（用户自行托管）

---

## 一、视频上传链路

前端用户上传视频到系统的入口。

**入口文件**: `app/api/upload/video/route.ts`

### 1.1 Vertex AI 模式（系统上传）

**流程**: 用户上传 → GCS 流式上传 → 返回公开 URL

**步骤**:
1. 接收前端 FormData，提取视频文件和 platform 参数
2. 校验文件大小（≤300MB）、MIME 类型、扩展名
3. 调用 GCS 客户端的流式上传方法，直接将文件流传到 GCS
4. 返回 GCS 公开 URL（`https://storage.googleapis.com/...`）

**关键位置**:
- 流式上传调用: `app/api/upload/video/route.ts:129-146`
- GCS 流式上传实现: `lib/storage/gcs-client.ts` (`uploadStream` 方法)

**返回数据**:
- `url`: GCS 公开 HTTPS URL
- `platform`: "vertex"

---

### 1.2 AI Studio 模式（系统上传）

**流程**: 用户上传 → 本地存储 + File API 上传 → 返回双 URI

**步骤**:
1. 接收前端 FormData，校验文件
2. 将文件内容读入内存（ArrayBuffer）
3. 写入本地 `temp/uploads/` 目录（供 FFmpeg 后续访问）
4. 同时上传到 Gemini File API（供 Gemini 分析使用）
5. 轮询等待 File API 处理完成（PROCESSING → ACTIVE）
6. 返回本地路径和 File API URI

**关键位置**:
- 本地存储: `app/api/upload/video/route.ts:157-171`
- File API 上传: `app/api/upload/video/route.ts:176-196`
- 轮询等待: `app/api/upload/video/route.ts:187-196`
- 路径常量: `lib/utils/paths.ts` (`UPLOADS_DIR`)

**返回数据**:
- `url`: `file://` 本地绝对路径（FFmpeg 访问）
- `fileApiUri`: Gemini File API URI（Gemini 分析）
- `expiresAt`: File API 48 小时有效期

**双 URI 设计原因**: File API URI 无法被 FFmpeg 访问，必须保留本地副本。

---

### 1.3 外部存储桶直链（R2/S3/其他 HTTPS）

**场景**: 用户不通过系统上传，直接提供外部存储桶的公开直链 URL。

**支持的外部存储类型**:
- Cloudflare R2: `https://xxx.r2.dev/...` 或 `https://xxx.r2.cloudflarestorage.com/...`
- Amazon S3: `https://xxx.s3.xxx.amazonaws.com/...`
- 其他公开 HTTPS URL

**流程**: 用户提供直链 URL → 系统直接使用

**前提条件**:
1. URL 必须是公开可访问的（无需认证）
2. URL 必须返回视频文件（非重定向到登录页）
3. URL 支持 Range 请求（用于 FFprobe 分析）

**关键位置**:
- URL 类型检测: `lib/ai/gemini/utils/url-converter.ts:33-72`
- R2 检测规则: `lib/ai/gemini/utils/url-converter.ts:51-54`
- S3 检测规则: `lib/ai/gemini/utils/url-converter.ts:56-59`

**平台限制**:
- **AI Studio 模式**: 支持所有外部 URL，系统会下载并上传到 File API
- **Vertex AI 模式**: 不直接支持 R2/S3，系统会自动下载并上传到 GCS

**错误提示位置**: `lib/ai/gemini/utils/url-converter.ts:198-212`

---

## 二、Gemini 上传链路

工作流执行时，将视频准备好供 Gemini API 分析。

**入口文件**: `lib/workflow/steps/analysis/prepare-gemini.ts`

### 2.1 Vertex AI 模式

**流程**: 检测 URL 类型 → 跳过或流式上传 → 返回 gs:// URI

**步骤**:
1. 检测视频 URL 是否已在 GCS（`isGcsUrl()` 判断）
2. 如果已在 GCS，直接转换为 `gs://` URI，跳过上传
3. 如果是外部 URL，流式下载并上传到 GCS
4. 更新数据库的 `gemini_uri` 字段

**关键位置**:
- GCS URL 检测与跳过: `lib/workflow/steps/analysis/prepare-gemini.ts`
- 流式上传调用: `lib/workflow/steps/analysis/prepare-gemini.ts`
- URL 类型判断工具: `lib/ai/gemini/utils/url-converter.ts`

**Gemini 使用的 URI 格式**: `gs://bucket-name/path/to/video.mp4`

---

### 2.2 AI Studio 模式

**流程**: 检测 URL 类型 → 跳过或下载+上传 → 返回 File API URI + 保存 local_path

**v12.2.3 更新**: AI Studio 模式现在会保存 `local_path`，供 FFmpeg 拆条使用。

#### 场景1: 前端预上传（File API URI）

**步骤**:
1. 检测 `original_url` 是 File API URI（`isGeminiFileApiUri()` 判断）
2. 跳过上传，直接使用现有 URI
3. `local_path` 在任务创建时已由前端传入，通过 COALESCE 保留

**数据库字段**:
- `original_url`: File API URI（前端上传时返回）
- `local_path`: `temp/uploads/xxx.mp4`（前端上传时返回）
- `gemini_uri`: 同 `original_url`

#### 场景2: 外部 URL

**步骤**:
1. 检测 `original_url` 不是 File API URI
2. 流式下载视频到本地 `temp/jobs/{jobId}/video-N.mp4`
3. 从本地文件上传到 File API
4. 更新数据库的 `gemini_uri` 和 `local_path` 字段

**数据库字段**:
- `original_url`: 外部 HTTPS URL
- `local_path`: `temp/jobs/{jobId}/video-N.mp4`（upload 步骤设置）
- `gemini_uri`: File API URI

**关键位置**:
- File API URI 检测与跳过: `lib/workflow/steps/analysis/prepare-gemini.ts`
- 下载+上传逻辑: `lib/workflow/steps/analysis/prepare-gemini.ts`
- File API 上传实现: `lib/ai/gemini/file-manager.ts` (`uploadFromUrl` 函数)

**Gemini 使用的 URI 格式**: `https://generativelanguage.googleapis.com/v1beta/files/xxx`

---

### 2.3 外部存储桶直链（R2/S3/其他 HTTPS）

外部 URL 需要转换为 Gemini 可识别的格式。

#### Vertex AI 模式处理外部 URL

**流程**: 外部 URL → 流式下载 → 上传到 GCS → 返回 gs:// URI

**步骤**:
1. 检测 URL 不是 GCS 格式
2. 从外部 URL 流式下载视频
3. 流式上传到 GCS（避免内存峰值）
4. 返回 gs:// URI

**关键位置**: `lib/workflow/steps/analysis/prepare-gemini.ts`

#### AI Studio 模式处理外部 URL

**流程**: 外部 URL → 下载到本地 → 上传到 File API → 返回 File API URI + 保存 local_path

**v12.2.3 更新**: 现在会先下载到本地，保存 `local_path` 供 FFmpeg 使用。

**步骤**:
1. 检测 URL 不是 File API URI
2. 流式下载视频到本地 `temp/jobs/{jobId}/video-N.mp4`
3. 从本地文件上传到 Gemini File API
4. 更新数据库 `gemini_uri` 和 `local_path`

**关键位置**: `lib/workflow/steps/analysis/prepare-gemini.ts`

---

## 三、元数据获取链路

获取视频时长、分辨率等元数据。

**入口文件**: `lib/workflow/steps/analysis/fetch-metadata.ts`

**智能分流逻辑**: 检测 URL 类型，File API URI 走 Gemini API，其他走 FFprobe。

### 3.1 FFprobe 路径（GCS / 外部 URL / 本地文件）

**适用**: GCS URL、R2/S3 URL、其他 HTTPS URL、本地 `file://` 路径

**流程**: URL → FFprobe 远程/本地分析 → 返回完整元数据

**步骤**:
1. 检测 URL 类型不是 File API URI
2. FFprobe 通过 HTTP(S) 或本地路径分析视频头部
3. 返回时长、分辨率、帧率、文件大小

**关键位置**:
- FFprobe 处理分支: `lib/workflow/steps/analysis/fetch-metadata.ts:112-141`
- FFprobe 实现: `lib/media/operations/metadata.ts`

**返回数据**: duration, width, height, fps, file_size

**技术说明**: FFprobe 支持 HTTP Range 请求，只需下载视频头部即可获取元数据，无需下载整个文件。

---

### 3.2 Gemini API 路径（File API URI）

**适用**: AI Studio 前端上传返回的 `fileApiUri`

**流程**: File API URI → Gemini API 查询 → 返回有限元数据

**步骤**:
1. 检测 URL 是 File API URI
2. 提取 fileName，调用 `files.get()` API 获取文件信息
3. 从响应中解析时长和文件大小

**关键位置**:
- File API 处理分支: `lib/workflow/steps/analysis/fetch-metadata.ts:70-109`
- File API 元数据获取: `lib/ai/gemini/file-manager.ts` (`getFileMetadata` 函数)

**返回数据**: duration, file_size（无法获取分辨率、帧率）

**限制说明**: Gemini File API 不返回视频分辨率信息，resolution 字段返回 "unknown"。

---

## 四、FFmpeg 拆条链路

将源视频按分镜时间戳切割成多个片段。

**入口文件**: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`

### 4.1 通用流程（两种模式共用）

**前提**: FFmpeg 只能访问本地文件或 HTTP(S) URL，无法访问 File API URI。

**流程**: 加载分镜数据 → 按源视频分组 → 批量拆条 → 输出本地文件

**步骤**:
1. 从数据库加载分镜列表和视频列表
2. 检测是否有 File API URI（无法处理，报错提示重新上传）
3. 检查磁盘空间是否充足
4. 检测各视频音轨状态（有/无音轨）
5. 计算目标分辨率（多视频时统一为众数分辨率）
6. 按源视频分组，逐个视频批量拆条
7. 输出本地视频文件到 `./outputs/` 目录

**关键位置**:
- local_path 检测与报错: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`missingLocalPath` 检查）
- 音轨检测: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`videoAudioStatus` 构建）
- 分辨率计算: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`calculateTargetResolution` 函数）
- 批量拆条调用: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`splitVideoBatch` 调用）
- FFmpeg 拆条实现: `lib/media/operations/split.ts`

**URL 使用逻辑**:
```typescript
videoUrl = local_path || gcs_https_url || original_url
```

**v12.2.3 更新**: 新增 `local_path` 优先级，AI Studio 模式优先使用本地文件。

| 场景 | `local_path` | `gcs_https_url` | `original_url` | FFmpeg 实际使用 |
|------|-------------|----------------|----------------|----------------|
| AI Studio 前端上传 | `temp/uploads/xxx` | - | File API URI | `local_path` ✓ |
| AI Studio 外部 URL | `temp/jobs/{jobId}/xxx` | - | 外部 HTTPS | `local_path` ✓ |
| Vertex AI 前端上传 | - | GCS HTTPS | GCS HTTPS | `gcs_https_url` ✓ |
| Vertex AI 外部 URL | - | GCS HTTPS | 原始外部 URL | `gcs_https_url` ✓ |

---

### 4.2 外部存储桶直链的处理

**流程**: 外部 HTTPS URL → FFmpeg 远程拉流拆条 → 输出本地文件

**步骤**:
1. FFmpeg 通过 HTTP(S) 协议远程读取视频流
2. 按时间戳切割，直接输出到本地文件
3. 无需先下载完整视频

**关键位置**: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`splitVideoBatch` 调用）

**技术说明**: FFmpeg 支持边下载边处理（流式处理），对于支持 Range 请求的存储桶可实现高效拆条。

**性能考虑**:
- R2/S3 等 CDN 存储桶通常有良好的网络性能
- 对于大文件，远程拆条比"下载→本地拆条"更节省磁盘空间
- 网络不稳定时可能导致拆条失败，需要重试

---

### 4.3 多视频分辨率统一策略

**触发条件**: 输入多个视频且分辨率不一致

**策略**: 使用众数分辨率（出现次数最多的分辨率）

**原因**: 最小化需要重编码的分镜数量

**关键位置**: `lib/workflow/steps/extract/ffmpeg-batch-split.ts`（`calculateTargetResolution` 函数）

---

## 五、音画同步链路

为每个分镜生成配音并与视频同步。

**入口文件**: `lib/workflow/steps/process/process-scene-loop.ts`

### 5.1 配音模式（AI 配音）

**流程**: 分镜 → TTS 多语速合成 → 选择最佳匹配 → 视频调速 → 音视频合成

**步骤**:
1. 获取分镜的旁白文本和视频时长
2. 调用 TTS 服务生成多个语速版本（如 0.9x, 1.0x, 1.1x）
3. 计算各音频与视频的时长匹配度
4. 选择最佳匹配的音频
5. 计算视频需要的调速因子
6. FFmpeg 调整视频速度
7. FFmpeg 合并音频和视频
8. 输出最终分镜视频

**关键位置**:
- 处理入口: `lib/workflow/steps/process/process-scene-loop.ts:136-140`
- 配音处理器: `lib/workflow/steps/process/handlers/dubbed-audio-handler.ts`
- 音频匹配算法: `lib/workflow/steps/process/utils/audio-matcher.ts`
- FFmpeg 调速: `lib/media/operations/speed.ts`
- FFmpeg 音视频合并: `lib/media/operations/merge.ts`

---

### 5.2 原声模式（保留原声）

**流程**: 分镜 → 直接使用拆条视频 → 更新状态

**步骤**:
1. 检测分镜标记为 `use_original_audio`
2. 直接将拆条后的视频作为最终视频
3. 无需 TTS、调速、合成

**关键位置**:
- 处理入口: `lib/workflow/steps/process/process-scene-loop.ts:136-140`
- 原声处理器: `lib/workflow/steps/process/handlers/original-audio-handler.ts`

---

### 5.3 断点续传支持

**机制**: 跳过已完成的分镜，只处理未完成的

**关键位置**: `lib/workflow/steps/process/process-scene-loop.ts:69-79`

---

## 六、合成输出链路

将所有处理完的分镜拼接成最终视频。

**入口文件**: `lib/workflow/steps/compose/concatenate-scenes.ts`

### 6.1 场景拼接

**流程**: 加载分镜 → 按序排列 → FFmpeg 拼接 → 输出本地文件

**步骤**:
1. 从数据库加载所有分镜
2. 过滤出有 `final_video_url` 的成功分镜
3. 按 `scene_index` 排序
4. 调用 FFmpeg concat demuxer 拼接
5. 输出到本地 `./outputs/` 目录

**关键位置**:
- 拼接步骤: `lib/workflow/steps/compose/concatenate-scenes.ts:42-110`
- FFmpeg 拼接实现: `lib/media/operations/concat.ts`

**容错机制**: 跳过失败的分镜，只拼接成功的

---

### 6.2 BGM 混音（可选）

**流程**: 拼接视频 → 混入 BGM → 输出最终文件

**关键位置**: `lib/workflow/steps/compose/add-bgm.ts`

---

### 6.3 最终输出

**Vertex AI 模式**: 上传到 GCS，返回公开 URL

**AI Studio 模式**: 保留本地文件，返回本地路径

**关键位置**: `lib/workflow/steps/compose/download.ts`

---

## 七、URL 类型速查

| URL 格式 | 示例 | 来源 | FFmpeg 可访问 | Gemini 可直接用 |
|---------|------|------|--------------|----------------|
| GCS gs:// | `gs://bucket/video.mp4` | Vertex AI | 否（需转 HTTPS） | 是（Vertex） |
| GCS HTTPS | `https://storage.googleapis.com/...` | Vertex AI | 是 | 需转 gs:// |
| File API URI | `https://generativelanguage.googleapis.com/...` | AI Studio | 否 | 是（AI Studio） |
| 本地 file:// | `file:///path/to/video.mp4` | AI Studio 上传 | 是 | 否 |
| R2 | `https://xxx.r2.dev/...` | 外部存储桶 | 是 | 否（需上传） |
| S3 | `https://xxx.s3.amazonaws.com/...` | 外部存储桶 | 是 | 否（需上传） |
| 其他 HTTPS | `https://example.com/video.mp4` | 外部源 | 是 | 否（需上传） |

**URL 类型检测函数**: `detectUrlType()` 位于 `lib/ai/gemini/utils/url-converter.ts:33-72`

**URL 类型枚举**: `gcs` | `r2` | `s3` | `file-api` | `local` | `https` | `unknown`

---

## 八、文件索引

| 链路 | 关键文件 |
|------|---------|
| 前端上传 | `app/api/upload/video/route.ts` |
| GCS 客户端 | `lib/storage/gcs-client.ts` |
| Gemini 上传 | `lib/workflow/steps/analysis/prepare-gemini.ts` |
| 元数据获取 | `lib/workflow/steps/analysis/fetch-metadata.ts` |
| FFmpeg 拆条 | `lib/workflow/steps/extract/ffmpeg-batch-split.ts` |
| 音画同步 | `lib/workflow/steps/process/process-scene-loop.ts` |
| 配音处理 | `lib/workflow/steps/process/handlers/dubbed-audio-handler.ts` |
| 原声处理 | `lib/workflow/steps/process/handlers/original-audio-handler.ts` |
| 场景拼接 | `lib/workflow/steps/compose/concatenate-scenes.ts` |
| BGM 混音 | `lib/workflow/steps/compose/add-bgm.ts` |
| FFmpeg 服务 | `lib/media/ffmpeg-service.ts`（门面类） |
| FFmpeg 操作 | `lib/media/operations/`（实际实现目录） |
| URL 工具 | `lib/ai/gemini/utils/url-converter.ts` |
| File API | `lib/ai/gemini/file-manager.ts` |
| 路径常量 | `lib/utils/paths.ts` |
| 文件清理 | `lib/utils/file-cleaner.ts` |

### FFmpeg 操作目录结构

| 操作 | 文件 |
|------|------|
| 元数据获取 | `lib/media/operations/metadata.ts` |
| 视频拆分 | `lib/media/operations/split.ts` |
| 视频调速 | `lib/media/operations/speed.ts` |
| 音视频合并 | `lib/media/operations/merge.ts` |
| 视频拼接 | `lib/media/operations/concat.ts` |
| BGM 混音 | `lib/media/operations/mix-bgm.ts` |
| 字幕烧录 | `lib/media/operations/subtitle.ts` |

---

## 九、大文件处理说明

### AI Studio 模式内存峰值

由于 Google GenAI SDK 的 `client.files.upload()` 接受 Blob 参数，整个文件必须加载到内存：

| 阶段 | 方法 | 内存占用 |
|-----|------|---------|
| 下载到本地 | `downloadToFile` 流式写入 | ~8KB（缓冲区） |
| 上传到 File API | `readFile()` → Blob | **~文件大小**（全量读入） |

### 各大小文件评估

| 文件大小 | 内存峰值 | 结论 |
|---------|---------|------|
| 100MB | ~100MB | ✓ 安全 |
| 300MB | ~300MB | ✓ 可接受（需 1GB+ 空闲内存） |
| >300MB | 超限 | ✗ 系统限制 300MB |

### Vertex AI 模式

Vertex AI 使用 GCS 流式上传（`uploadFromUrlStreaming`），无内存峰值限制。

---

## 十、潜在风险与注意事项

### ⚠ 风险1: 本地文件清理

**现象**: `temp/` 目录下的临时文件会累积

**影响**: 磁盘空间耗尽

**目录结构**:
```
temp/
├── uploads/     # 前端上传视频（48 小时保留）
└── jobs/        # 外部 URL 下载（任务完成后清理）
    └── {jobId}/
```

**清理方式**:
- 统一入口: `/api/storage/cleanup?mode=temp`
- 清理函数: `lib/utils/file-cleaner.ts` → `cleanAllTempFiles()`
- 路径常量: `lib/utils/paths.ts` → `TEMP_ROOT`, `UPLOADS_DIR`, `JOBS_DIR`

**保留策略**:
- `temp/uploads/`: 48 小时（对应 File API 有效期）
- `temp/jobs/{jobId}/`: 任务完成后自动清理

---

### ⚠ 风险2: File API 48小时有效期

**现象**: File API URI 48小时后过期

**影响**: 长时间暂停的任务可能因 URI 过期而失败

**当前缓解**:
- 前端上传时返回 `expiresAt` 字段
- 前端可提示用户在有效期内完成任务

---

### ⚠ 风险3: 前端预上传文件缺失

**场景**: 用户上传视频后，服务重启导致 `temp/uploads/` 目录清空

**现象**: `local_path` 指向不存在的文件

**影响**: FFmpeg 拆条时报错 "Failed to split videos"

**当前检测**: `ffmpeg-batch-split.ts` 中的 `missingLocalPath` 检查

**建议**: 在 FFmpeg 拆条前检查 `local_path` 文件是否存在，不存在则提示用户重新上传
